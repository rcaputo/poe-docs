# $Header$

=pod

=head1 NAME

poesess - POE sessions and their innerworkings

=head1 DATE

$Date$

=head1 DESCRIPTION

There are four ways to code your POE sessions: Anonymous inline subrefs,
Inline subrefs, Package methods, Object methods. Which you use is really 
up to personal preference. All but anonymous subrefs allow code reuse in 
one form or another.

=head2 Anonymous inline subrefs

In this form, each event is an anonymous subref defined at or before 
creating the session.

    POE::Session->create(
        inline_states => {
            _start => sub {
                my ($kernel) = $_[KERNEL];
                $kernel->alias_add($alias);
                $heap->{reg} = [];
            },

            xmit => sub {
                my ($kernel, $heap, $something) = @_[KERNEL, HEAP, ARG0];
                foreach my $s (@{$heap->{reg}}) {
                    $kernel->post(@$s, $something);
                }
                return;
            },

            join => sub {
                my ($kernel, $heap, $something) = @_[KERNEL, HEAP, ARG0];
                push @{$heap->{reg}}, $something;
                return;
            },

            split => sub {
                my ($kernel, $heap, $something) = @_[KERNEL, HEAP, ARG0];
                $heap->{reg}=[grep {$_->[0] ne $something->[0] or
                                    $_->[1] ne $something->[1]} $something];
                return;
            },
        }
    );

This type of event would be good for small "glue" sessions that just 
interface POE with a worker object.

    POE::Session->create(
        inline_states => {
            question => sub {
                my ($kernel, $heap, $back, $question) = @_[KERNEL, HEAP, ARG0,ARG1];
                my $ret = $heap->{worker}->question($question);
                $kernel->post($kernel->sender, $back, $ret);
            },
        }

Advantages :

=over 4

=item * code and session definition in the same place.

=item * less name space noise

=back

Disadvantages :

=over 4

=item * Beyond cut and paste, you can't reuse the code.

=item * C<name=E<gt>sub { ... }> is less like I<normal> perl then C<sub name { ... }>

=item * for complex sessions, create() will become large, unwieldly and harder to understand

=back



=head2 Inline subrefs

With this of event, create() is used to map an event name to a perl
subroutine.

    POE::Session->create(
        inline_states => {
            _start => \&start_event,
            xmit   => \&xmit_event,
            join   => \&join_event,
            split  => \&split_event,
        },
        args => [$alias],
    );

    sub start_event {
        my ($kernel, $alias) = @_[KERNEL, ARG0];
        $kernel->alias_add($alias);
        $heap->{reg}=[];
    }

    sub xmit_event {
        my ($kernel, $heap, $something) = @_[KERNEL, HEAP, ARG0];
        foreach my $s (@{$heap->{reg}}) {
            $kernel->post(@$s, $something);
        }
        return;
    }

    sub join_event {
        my ($sender, $heap, $something) = @_[SENDER, HEAP, ARG0];
        push @{$heap->{reg}}, [$sender->ID, $something];
        return;
    }

    sub split_event {
        my ($sender, $heap, $something) = @_[SENDER, HEAP, ARG0];
        $sender=$sender->ID;
        $heap->{reg}=[grep {$_->[0] ne $sender] or
                            $_->[1] ne $something} @{$heap->{reg}];
        return;
    }


This is the easiest form for a novice to grok.  No packages, no objects,
just straight subroutines like everyone else.  

For code reuse, simply reference the subs from another package.

    POE::Session->create(
        inline_states => {
            _start => \&start_event,
            xmit   => \&xmit_event,
            join   => \&one_join_event,
            split  => \&one_split_event,
        },
        args => [$alias],
    );

    sub one_join_event {
        my ($sender, $heap, $something) = @_[SENDER, HEAP, ARG0];
        $sender = $sender->ID;
        push @{$heap->{reg}}, [$sender, $something]
                 unless $heap->{already}{$sender}{$something}++;
        return;
    }

    sub one_split_event {
        my ($sender, $heap, $something) = @_[SENDER, HEAP, ARG0];
        my $sender = $sender->ID;
        if($something) {
            delete $heap->{already}{$sender}{$something};
            delete $heap->{already}{$sender} 
                        unless keys %{$heap->{already}{$sender}};
        } else {
            delete $heap->{already}{$sender};
        }

        $heap->{reg}=[grep {$heap->{already}{$_->[0]} and
                            $heap->{already}{$_->[0]}{$_->[1]}}
                           @{$heap->{reg}}];
        return;
    }
    


Advantages:

=over 4

=item * Easy to understand.

=item * Good code reuse (Exporter)

=back

Disadvantages:

=over 4

=item * Name space polution

=item * Event name isn't necessarily the same as the subroutine name that implements it.  

=item * SUPER:: not available

=back 



=head2 Package Methods

This is my favorite form of POE.  All events are mapped to package methods.

    package BCast;

    sub spawn {
        my ($package, $alias) = @_;
        POE::Session->create(
            package_states => {
                $package=>[qw(_start xmit join split)],
            },
            args => [$alias],
        );
    }

    sub _start {
        my ($kernel, $alias) = @_[KERNEL, ARG0];
        $kernel->alias_add($alias);
        $heap->{reg} = [];
    }

    sub xmit {
        my ($kernel, $heap, $something) = @_[KERNEL, HEAP, ARG0];
        foreach my $s (@{$heap->{reg}}) {
            $kernel->post(@$s, $something);
        }
        return;
    }

    sub join {
        my ($kernel, $heap, $something) = @_[KERNEL, HEAP, ARG0];
        push @{$heap->{reg}}, $something;
        return;
    }


    sub split {
        my ($kernel, $heap, $something) = @_[KERNEL, HEAP, ARG0];
        $heap->{reg}=[grep {$_->[0] ne $something->[0] or
                            $_->[1] ne $something->[1]} @{$heap->{reg}];
        return;
    }

With this form, it becomes dead simple to reuse code.  Simply overload the
the package :

    package BCast::Once;

    use base qw(BCast);

    sub join {
        my ($sender, $heap, $something) = @_[SENDER, HEAP, ARG0];
        
        $heap->{joined}{$sender->ID}{$something} = 1;
        delete $heap->{reg};
        return;
    }

    sub split {
        my ($sender, $heap, $something) = @_[SENDER, HEAP, ARG0];
        my $sender = $sender->ID;
        if($something) {
            delete $heap->{already}{$sender}{$something};
            delete $heap->{already}{$sender} 
                        unless keys %{$heap->{already}{$sender}};
        } else {
            delete $heap->{already}{$sender};
        }
        delete $heap->{reg};
    }

    sub xmit {
        my ($heap) = $_[HEAP];
        $heap->{reg} ||= [map {keys %$_} keys %{$heap->{already}}];
        $package = shift @_;
        $package->SUPER::xmit(@_);
        return;
    }

Advantages:

=over 4

=item * Inteligent use of packages

=item * Event name == subroutine name

=back

Disadvantages:

=over 4

=item * You depend on the heap.

=item * Some folks don't like OO.

=item * Because @_ has so much in it, one has to do silly things like C<shift(@_)->SUPER::subroutine(@_);> to call parent methods.

=item * Non-POE related methods won't have access to $_[HEAP] where we store all information.

=back


=head2 Object Methods


    package BCast;

    sub spawn {
        my ($package, $alias) = @_;
        my $self = $package->new($alias);
        POE::Session->create(
            object_states => {
                $self => [qw(_start xmit join split)],
            },
        );
    }

    sub new {
        my ($package, $alias) = @_;
        return bless {alias => $alias}, $package;
    }

    sub _start {
        my ($kernel, $self) = @_[KERNEL, OBJECT];
        $kernel->alias_add($self->{alias});
        $self->{reg} = [];
    }

    sub xmit {
        my ($kernel, $self, $something) = @_[KERNEL, OBJECT, ARG0];
        foreach my $s (@{$self->{reg}}) {
            $kernel->post(@$s, $something);
        }
        return;
    }

    sub join {
        my ($kernel, $self, $something) = @_[KERNEL, OBJECT, ARG0];
        push @{$self->{reg}}, $something;
        return;
    }

    sub split {
        my ($kernel, $self, $something) = @_[KERNEL, OBJECT, ARG0];
        $self->{reg}=[grep {$_->[0] ne $something->[0] or
                            $_->[1] ne $something->[1]} @{$self->{reg}];
        return;
    }

With this form, it becomes dead simple to reuse code.  Simply overload the
the package :

    package BCast::Once;

    use base qw(Base);

    sub join {
        my ($sender, $self, $something) = @_[SENDER, OBJECT, ARG0];
        
        $self->{joined}{$sender->ID}{$something} = 1;
        delete $self->{reg};
        return;
    }

    sub split {
        my ($sender, $self, $something) = @_[SENDER, OBJECT, ARG0];
        my $sender=$sender->ID;
        if($something) {
            delete $self->{already}{$sender}{$something};
            delete $self->{already}{$sender} 
                        unless keys %{$self->{already}{$sender}};
        } else {
            delete $self->{already}{$sender};
        }
        delete $self->{reg};
    }

    sub xmit {
        my $self = shift;
        $self->{reg} ||= [map {keys %$_} keys %{$self->{already}}];
        $self->SUPER::xmit(@_);
        return;
    }


This looks stunningly similar Package methods, only HEAP and $heap have been replaced with OBJECT and $self.  This is because that's exactly what I've done.


Advantages:

=over 4

=item * Fully OO

=item * C<$_[OBJECT]> can have non-POE related methods, because we don't depend on C<$_[HEAP]>.

=item * Sessions can be amalgams of several objects.

=back

Disadvantages:

=over 4

=item * Some people don't like OO

=item * Because @_ has so much in it, one has to do silly things like C<shift(@_)->SUPER::subroutine(@_);> to call parent POE-related methods.

=back

=head1 AUTHOR

This content was taken from the POE Wiki and is copyright (c) 2001 Philip Gwyn.
This content is distributed under the terms of Perl itself.

=cut 
