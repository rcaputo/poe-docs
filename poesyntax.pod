# $Header$

=pod

=head1 NAME
    
poesyntax - POE syntax and general usage    

=head1 DATE

$Date$

=head1 SYNOPSIS

    #!/usr/bin/perl -w
    use strict;

    # Use POE!
    use POE;

    # Every session must handle a special event, _start.  It's used to
    # tell the session that it has been successfully instantiated.
    # $_[KERNEL] is a reference to the program's global POE::Kernel
    # instance; $_[HEAP] is the session's local storage; $_[SESSION] is
    # a reference to the session itself.

    sub handler_start {
        my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];
        print "Session ", $session->ID, " has started.\n";
        $heap->{count} = 0;
        $kernel->yield('increment');
    }

    sub handler_increment {
        my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];
        print "Session ", $session->ID, " counted to ", ++$heap->{count}, ".\n";
        $kernel->yield('increment') if $heap->{count} < 10;
    }

    # The _stop event is special but, handling it is not required.  It's
    # used to tell a session that it's about to be destroyed.  _stop
    # handlers perform shutdown things like resource cleanup or
    # termination logging.

    sub handler_stop {
        print "Session ", $_[SESSION]->ID, " has stopped.\n";
    }

    # Start ten sessions.  POE::Session constructors map event names to
    # the code that handles them.

    for (0..9) {
        POE::Session->create(
            inline_states => { 
                _start    => \&handler_start,
                increment => \&handler_increment,
                _stop     => \&handler_stop,
            }
        );
    }

    # Start the kernel, which will run as long as there are sessions.

    $poe_kernel->run();
    exit;

=head1 USING POE

Using POE could be pretty tedious.  Consider this example, which pulls
in the necessary modules for a line-based TCP server:

  use POE::Kernel;
  use POE::Session;
  use POE::Wheel::SocketFactory;
  use POE::Wheel::ReadWrite;
  use POE::Filter::Line;
  use POE::Driver::SysRW;

The POE.pm module fixes some of this tedium.  When POE.pm is used
directly, it automatically includes POE::Kernel and POE::Session.  It
also includes each of the C<use> statement's parameters, first
prepending "POE::" to them.  An example is in order:

This C<use> statement is equivalent to the previous six.

    use POE qw( Wheel::SocketFactory Wheel::ReadWrite
                Filter::Line Driver::SysRW
              );

=head1 WRITING POE PROGRAMS

Basic POE programs have four parts.


=head2 Preliminary program setup

This is the usual overhead for writing a Perl program: a shebang line,
perhaps some C<use> statements to import things, and maybe some global
variables or configuration constants.  It's all pretty standard stuff.

    #!/usr/bin/perl -w
    use strict;
    use POE;

=head2 Define the program's event handlers or states

Declare functions which will handle events here.  This is deceptive,
since the functions can be declared anywhere, including as anonymous
subroutines in a session constructor call.

    sub handler_start {
        ...
    }

    sub handler_increment {
        ...
    }

    sub handler_stop {
        ...
    }

=head2 Start initial sessions or machines

The Kernel only runs as long as there is something for it to do.  It's
main loop returns after the last session has stopped.  The obvious
corolary to this rule is that the main loop will return immediately if
nothing is set up when it's called.

    for (0..9) {
        POE::Session->create(
            inline_states => {   
                                _start    => \&handler_start,
                                increment => \&handler_increment,
                                _stop     => \&handler_stop,
                             }
            );
    }

=head2 Start the kernel's main loop

_start handlers are invoked immediately when sessions are
instantiated.  Everything else happens because the kernel makes it so,
and the kernel can't do that 'til it's started.  Most programs exit
afterwards since the kernel only returns after everything is done.

    $poe_kernel->run();
    exit;

=head1 POE COMPONENTS

Components consist of one or more sessions or state machines that
encapsulate a very high level procedure.  For example,
POE::Component::IRC (not included) performs nearly all the functions
of a full-featured IRC client.  POE::Component::UserBase (not
included) is a user authentication and data persistence servlet.

Components tend to be highly reusable core libraries that handle
tedious tasks, freeing programmers to focus on more interesting
things.  This should be true for any library, though.



